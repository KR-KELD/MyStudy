struct BufType
{
	float2 vPickPos;	
	float2 vRadius;
	int    iIndex;// rgba
	float  fTexWidth;
	float  fTexHeight;
};
//Texture2D<float4>			InputMap  : register(t0);
Texture2D<float4>			CopyMap   : register(t0);
StructuredBuffer<BufType>   SelectMap : register(t1);
RWTexture2D<float4>			OutputMap  : register(u0);

#define size_x 32
#define size_y 32

[numthreads(size_x, size_y,1)]
void CS( uint3 GroupID : SV_GroupID,
         uint3 DispatchThreadID : SV_DispatchThreadID, // 필수
		 uint3 GroupThreadID : SV_GroupThreadID,
		 uint  GroupIndex : SV_GroupIndex)
{
	int3 texturelocation = int3(0,0,0);
	//texturelocation.x = GroupID.x * size_x + GroupThreadID.x; // 1*32+ 133
	//texturelocation.y = GroupID.y * size_y + GroupThreadID.y; //33
	texturelocation.x = DispatchThreadID.x;
	texturelocation.y = DispatchThreadID.y;	
	// 0 ~ 1024 -> 0~1
	float2 txPos = texturelocation.xy;
	//float1 w = SelectMap[0].fTexWidth / 2.0f;
	//float1 h = SelectMap[0].fTexHeight / 2.0f;
	//float3 txPos = float3(	texturelocation.x-w,
	//						0.0f,-(texturelocation.y-h)	);	
	float1 fDistance = distance(txPos, SelectMap[0].vPickPos);

	float4 vAlphaColor = CopyMap.Load(texturelocation);

	if(fDistance < SelectMap[0].vRadius.x)
	{		
		float fDot = 1.0f-(fDistance/SelectMap[0].vRadius.x);
		if (fDistance < SelectMap[0].vRadius.y)
		{
			fDot = 1.0f;
		}
		else
		{
			float1 fRatio = (fDistance - SelectMap[0].vRadius.y) / 
				(SelectMap[0].vRadius.x -  SelectMap[0].vRadius.y);
			fDot = lerp(1.0f,0.0f,fRatio);
		}
		switch(SelectMap[0].iIndex)
		{
		case 0 : vAlphaColor.x = max(vAlphaColor.x, fDot);break;
		case 1 : vAlphaColor.y = max(vAlphaColor.y, fDot);break;
		case 2 : vAlphaColor.z = max(vAlphaColor.z, fDot);break;
		case 3 : vAlphaColor.w = max(vAlphaColor.w, fDot);break;
		}
		OutputMap[texturelocation.xy] = vAlphaColor;
		//OutputMap[texturelocation.xy] = float4(fDot,fDot,fDot,1);
	}		
}
